---
title: 关系数据库标准语言SQL（一）
date: 2016-11-22 16:45:03
tags: [数据库,SQL]
categories: [读书笔记,数据库系统概论]
---
结构化查询语言（Structured Query Language,SQL）是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言。其功能不仅仅是查询，而是包括数据库模式创建、数据库数据的插入与修改、数据库安全性完整性定义与控制等一系列功能。
<!--more-->
# SQL概述
## SQL的产生和发展
SQL是在1974年由Boyce和Chamberlin提出的，最初叫Sequel，并在IBM公司研制的关系数据库管理系统原型System R上实现。目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。许多软件厂商对SQL基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性。
## SQL的特点
1.综合统一：集多重功能于一体。
2.高度非过程化：只要提出“做什么”，而无须指明“怎么做”。
3.面向集合的操作方式。
4.以同一种语法结构提供多种使用方式：SQL既是独立的语言，又是嵌入式语言。
5.语言简洁，易学易用。

## SQL的基本概念
支持SQL的关系数据库管理系统同样支持关系数据库三级模式结构。
![关系数据库标准语言SQL1](http://ofolh8dcq.bkt.clouddn.com/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL1.gif)
# 数据定义
SQL的数据定义语句

操作对象|创建         |删除       |修改
--------|-------------|-----------|-----------
模式    |CREATE SCHEMA|DROP SCHEMA|
表      |CREATE TABLE |DROP TABLE |ALTER TABLE
视图    |CREATE VIEW  |DROP VIEW  |
索引    |CREATE INDEX |DROP INDEX |ALTER INDEX

一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。
## 模式的定义与删除
### 定义模式
```sql
CREATE SCHEMA<模式名>AUTHORIZATION<用户名>；
```
如果没有指定<模式名>，那么<模式名>隐含为<用户名>。要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授权的CREATE SCHEMA的权限。
目前，在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图，定义授权。即
```sql
CREATE SCHEMA<模式名>AUTHORIZATION<用户名>[<表定义子句>|<视图定义子句>|<授权定义子句>];
```
### 删除模式
```sql
DROP SCHEMA<模式名><CASCADE|RESTRICT>;
```
其中CASCADE和RESTRICT两者必选其一。选择了CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行DROP SCHEMA语句。
## 基本表的定义、删除与修改
### 定义基本表
```sql
CREATE TABLE<表名>(<列名><数据类型>[列级完整性约束条件],
                   <列名><数据类型>[列级完整性约束条件],
			...
			[表级完整性约束条件]
			);
```
建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级上也可以定义在表级。
### 数据类型
数据类型|含义
--------|----
CHAR(n),CHARACTER(n)|长度为n的定长字符串
VARCHAR(n),CHARACTERVARYING(n)|最大长度为n的变长字符串
CLOB|字符串大对象
BLOB|二进制大对象
INT,INTEGER|长整数（4字节）
SMALLINT|短整数（2字节）
BIGINT|大整数（8字节）
NUMERIC(p,d)|定位数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字
DECIMAL(p,d),DEC(p,d)|同NUMERIC
REAL|取决于机器精度的单精度浮点数
DOUBLE PRECISION|取决于机器精度的双精度浮点数
FLOAT(n)|可选精度的浮点数，精度至少为n位数字
BOOLEAN|逻辑布尔量
DATE|日期，包含年、月、日，格式为YYYY-MM-DD
TIME|时间，包含一日的时、分、秒，格式为HH:MM:SS
TIMESTAMP|时间戳类型
INTERVAL|时间间隔类型
### 模式与表
每个基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式：
1.方法一，在表名中明显地给出模式名。例如CREATE TABLE "S-T".Student(...);  Student所属的模式是S-T
2.方法二，在创建模式语句中同时创建表。
2.方法三，设置所属的模式，这样在创建表时表名中不必给出模式名。

当用户创建基本表（其他数据库对象也一样）时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。
使用下面语句可以显示当前的搜索路径：
```sql
SHOW search_path;
```
搜索路径的当前默认值是$user,PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式。
### 修改基本表
```sql
ALTER TABLE <表名>
[ADD [COLUMN] <新列名><数据类型>[完整性约束]]
[ADD <表级完整性约束>]
[DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
[DROP CONSTRAINT<完整性约束名>[RESTRICT|CASCADE]]
[ALTER COLUMN <列名><数据类型>];
```
其中<表名>是要修改的基本表，ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。DROP COLUMN子句用于删除表中的列，如果指定了CASCADE短语，则自动删除引用了该列的其他对象，比如视图；如果指定了RESTRICT短语，则如果该列被其他对象引用，RDBMS将拒绝删除该列。DROP CONSTRAINT子句用于删除指定的完整性约束条件。ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型。
### 删除基本表
```sql
DROP TABLE <表名>[RESTRICT|CASCADE];
```
若选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如CHECK，FOREIGN KEY等约束），不能有视图，不能有触发器（trigger），不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。默认情况是RESTRICT。
## 索引的建立与删除
当表的数据量比较大时，查询操作会比较耗时。建立索引是加快查询速度的有效手段。数据库索引有多种类型，常见的索引包括**顺序文件上的索引**、**B+树索引**、**散列索引**、**位图索引**等。索引虽然能够加速数据库查询，但需要占用一定的存储空间，当基本表更新时，索引要进行相应的维护，这些都会增加数据库的负担，因此要根据实际应用的需要有选择地创建索引。
一般来说，建立与删除索引有数据库管理员或表的属主，即建表的人，负责完成。关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显示地选择索引。索引是关系数据库管理系统的内部实现技术，属于内模式的范畴。
### 建立索引
```sql
CREATE [UNIQUE][CLUSTER] INDEX <索引名> ON <表名>(<列名>[<次序>],<列名>[<次序>],...);
```
其中，<表名>是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个<列名>后面还可以用<次序>指定索引值的排列次序，可选ASC（升序）或DESC（降序），默认值为ASC。UNIQUE表明此索引的每一个索引值只对应唯一的数据记录。CLUSTER表示要建立的索引是聚族索引。
### 修改索引
```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>;
```
### 删除索引
```sql
DROP INDEX <索引名>;
```
## 数据字典
数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。在进行查询优化和查询处理时，数据字典中的信息是其重要依据。
# 数据查询
见关系数据库标准语言SQL（二）
# 数据更新
数据更新操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。
## 插入数据
SQL的数据插入语句INSERT通常有两种形式：一种是插入一个元组，另一个是插入子查询结果。后者可以一次插入多个元组。
### 插入元组
```sql
INSERT
INTO <表名>[(<属性列1>,<属性列2>,...)]
VALUES (<常量1>,<常量2>,...);
```
其功能是将新元组插入指定表中。其中新元组的属性列1的值为常量1，属性列2的值为常量2，...。INTO子句中没有出现的属性列，新元组在这些列上将取空值。但必须注意的是，在表定义时说明了NOT NULL的属性列不能取空值，否则会出错。如果INTO子句没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值。例如：
```sql
INSERT
INTO Student(Sno,Sname,Ssex,Sdept,Sage)
VALUES ('201515128','陈冬','男','IS',18);
```
属性的顺序可以与CREATE TABLE中的顺序可以不一样。字符串常数要用单引号括起来。
### 插入子查询结果
子查询不仅可以嵌套在SELECT语句中用以构造父查询的条件，也可以嵌套在INSERT语句中用以生成要插入的批量数据。
```sql
INSERT
INTO <表名> [(<属性列1>,<属性列2>,...)]
子查询;
```
例如：
```sql
INSERT
INTO Dept_age(Sdept,Avg_age)
SELECT Sdept,AVG(Sage)
FROM Student
GROUP BY Sdept;
```
## 修改数据
修改操作又称为更新操作。
```sql
UPDATE <表名>
SET <列名>=<表达式>,<列名>=<表达式>,...
[WHERE <条件>];
```
其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出的<表达式>的值用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。
### 修改某一个元组的值
例如：
```sql
UPDATE Student
SET Sage=22
WHERE Sno='201215121';
```
### 修改多个元组的值
例如：
```sql
UPDATE Student
SET Sage=Sage+1;
```
### 带子查询的修改语句
子查询也可以嵌套在UPDATE语句中，用以构造修改的条件。例如：
```sql
UPDATE SC
SET Grade=0
WHERE Sno IN
	(SELECT Sno
	FRON Student
	WHERE Sdept='CS');
```
## 删除数据
```sql
DELETE
FROM <表名>
[WHERE <条件>];
```
DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句则表示删除表中全部元组，但表的定义仍在字典中。也就是说，DELETE语句删除的是表中的数据，而不是关于表的定义。
### 删除某一个元组的值
```sql
DELETE
FROM Student
WHERE Sno='201215128';
```
### 删除多个元组的值
```sql
DELETE
FROM SC;
```
### 带有子查询的删除语句
子查询同样也可以嵌套在DELETE语句中，用以构造执行删除操作的条件。例如：
```sql
DELETE
FROM SC
WHERE Sno IN
		(SELECT Sno
		FROM Student
		WHERE Sdept='CS');
```
# 空值的处理
所谓空值就是“不知道”或“不存在”或“无意义”的值。SQL语言中允许某些元组的某些属性在一定情况下取空值。一般存在以下几种情况：
- 该属性应该有一个值，但目前不知道它的具体值。
- 该属性不应该有值。
- 由于某种原因不便于填写。

## 空值的产生
例如：
```sql
INSERT INTO SC(Sno,Cno,Grade)
	VALUES('201215126','1',NULL)  /*在插入时该学生还没有考试成绩，取空值*/

INSERT INTO SC(Sno,Cno)
	VALUES('201215126','1')   /*在插入语句中没有赋值的属性，其属性为空值*/

UPDATE Student
SET Sdept=NULL
WHERE Sno='201215200';
```
另外，外连接也会产生空值，空值的关系运算也会产生空值。
## 空值的判断
判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示。例如：
```sql
SELECT *
FROM Student
WHERE Sname IS NULL OR Ssex IS NULL OR Sage IS NULL OR Sdept IS NULL;
```
## 空值的约束条件
属性定义（或者域定义）中有NOT NULL约束条件的不能取空值，加了UNIQUE限制的属性不能取空值，码属性不能取空值。
## 空值的算术运算、比较运算和逻辑运算
空值与另一个值（包括另一个空值）的算术运算的结果为空值，空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。有了UNKNOWN后，传统的逻辑运算中二值（TRUE,FALSE）逻辑就扩展成了三值逻辑。
在查询语句中，只有使WHERE和HAVING子句中的选择条件为TRUE的元组才被选出作为输出的结果。
# 视图
视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。
## 定义视图
### 建立视图
```sql
CREATE VIEW <视图名> [(<列名>,<列名>,...)]
AS <子查询>
[WITH CHECK OPTION];
```
其中，子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则取决于具体系统的实现。WITH CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。
组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名：
- 某个目标列不是单纯的属性名，而是聚集函数或列表达式；
- 多表连接时选出了几个同名列作为视图的字段；
- 需要在视图中为某个列启用新的更合适的名字。

例如：
```sql
CREATE VIEW IS_Student
AS
SELECT Sno,Sname,Sage
FROM Student
WHERE Sdept='IS'
WITH CHECK OPTION;
```
由于在定义IS_Student视图时加上了WITH CHECK OPTION子句，以后对该项视图进行插入、修改和删除操作时，关系数据库管理系统会自动加上Sdept='IS'的条件。关系数据库管理系统执行CREATE VIEW语句的结果只是把视图的定义存入数据字典，并不执行其中的SELECT语句。只是在对视图查询时，才按视图的定义从基本表中将数据查出。
若一个视图是从单个基本表中导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为**行列子集视图**。
视图不仅可以建立在单个基本表上，也可以建立在多个基本表上。例如：
```sql
CREATE VIEW IS_S1(Sno,Sname,Grade)
AS
SELECT Student.Sno,Sname,Grade
FROM Student,SC
WHERE Sdept='IS' AND Student.Sno=SC.Sno AND SC.Sno='1';
```
视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，或建立在基本表和视图上。例如：
```sql
CREATE VIEW IS_S2
AS
SELECT Sno,Sname,Grade
FROM IS_S1
WHERE Grade>=90;
```
定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据实际应用的需要设置一些派生属性列。这些派生属性列由于在基本表中并不实际存在，也称它们为虚拟列。带虚拟列的视图也称带表达式的视图。例如：
```sql
CREATE VIEW BT_S(Sno,Sname,Sbirth)
AS
SELECT Sno,Sname,2014-Sage
FROM Student;
```
还可以用带有聚集函数和GROUP BY子句的查询来定义视图，这种视图称为**分组视图**。例如：
```sql
CREATE VIEW S_G(Sno,Gavg)
AS
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno;
```
### 删除视图
```sql
DROP VIEW <视图名> [CASCADE];
```
视图删除后视图的定义将从数据字典中删除。如果该视图上还导出来其他视图，则使用CASCADE级联删除语句把该视图和由它导出的所有视图一起删除。
基本表删除后，由该基本表导出的所有视图均无法使用了，但是视图的定义没有从字典中清除。删除这些视图定义需要显式地使用DROP VIEW语句。
## 查询视图
视图定义后，用户就可以像对基本表一样对视图进行查询了。例如：
```sql
SELECT Sno,Sage
FROM IS_Student
WHERE Sage<20;
```
关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为**视图消解**。
定义视图并查询视图与基于派生表的查询是有区别的。视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而派生表只是在语句执行时临时定义，语句执行后该定义即被删除。
## 更新视图
更新视图是指通过视图来插入（INSERT）、删除（DELETE）和修改（UPDATE）数据。由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。
为防止用户通过视图对数据进行增加、删除、修改时，有意无意地对不属于视图范围内的基本表数据进行操作，可在定义视图时加上WITH CHECK OPTION子句。
例如：
```sql
UPDATE IS_Student
SET Sname='刘辰'
WHERE Sno='201215122';

INSERT
INTO IS_Student
VALUES('201215129','赵新',20);

DELETE
FROM IS_Student
WHERE Sno='201215129';
```
在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新。一般地，行列子集视图是可更新的。
## 视图的作用
1.视图能够简化用户的操作。
2.视图使用户能以多种角度看待同一数据。
3.视图对重构数据库提供了一定程度的逻辑独立性。尽管数据库的逻辑结构改变（例如新增一个基本表），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。
4.视图能够对机密数据提供安全保护。
5.适当利用视图可以更清晰地表达查询。


> 《数据库系统概论（第5版）》王珊 萨师煊 著
