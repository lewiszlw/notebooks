# Redis过期策略
**1.定期删除**

redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

**2.惰性删除**

在获取某个 key 的时候，redis 会检查一下 ，如果这个 key 设置了过期时间，并且已经过期了，那么就直接删除，返回空。

ps.如果大量的key没有被扫描到，且已过期，也没有被再次访问，即没有走惰性删除，这些大量过期 key 堆积在内存里，导致 redis 内存块耗尽了：redis提供内存淘汰机制（如LRU）。

# Redis优缺点
优点：
1. 数据存放在内存中，读写速度很快，采用单线程结构，防止了因多线程竞争可能出现的问题和消耗。
2. 数据类型丰富，五种基础数据类型，并且有很多很有用的扩展数据类型，如位图，HyperLogLog，发布订阅，GEO 等。
3. 功能丰富，提供键过期，简单事务，Lua 脚本管理，Pipeline 等功能。
4. 数据可持久化，可通过 RDB 和 AOF 两种方式进行数据持久化。
5. 提供主从复制，可利用集群，哨兵构建高可用的分布式架构。

缺点：
1. 不具备自动容错和恢复功能。
2. 主机宕机，宕机未同步到从机的数据无法恢复。
3. 主从复制采用全量复制，若快照文件过大，对集群的服务能力会产生较大影响。
4. 难以支持在线扩容。

# Redis高性能原因
1. 完全基于内存
2. 采用单线程，避免了不必要的上下文切换和竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 使用多路I/O复用模型，非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架
4. 数据结构简单

# Redis单线程原因
官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

# Redis持久化方式
**RDB方式**
把数据以快照的形式保存在磁盘上。通常采用的是fork创建子进程来进行持久化。提供手动触发和自动触发两种方式。通常用到 BGSAVE 命令来fork一个子进程进行备份，而 SAVE 会阻塞 Redis 导致备份期间不能执行其他命令。

优点：全量备份，非常适合用于进行备份和灾难恢复；最大化 Redis 的性能，只需要fork出一个子进程，父进程无须执行任何磁盘 I/O 操作；RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
缺点：快照持久化期间修改的数据不会被保存，可能丢失数据。数据集比较庞大时， fork() 可能会非常耗时。

**AOF方式**
AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据。默认情况下 AOF 功能是关闭的，Redis 只会通过 RDB 完成数据持久化的。也可以手动触发或者自动触发。

AOF 文件的写入流程可以分为以下 3 个步骤：
1. 命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 aof_buf
2. 文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 aof_buf 的数据同步到硬盘
3. 文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩

优点：数据更完整，安全性更高，秒级数据丢失；AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复。
缺点：对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢；根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。

# Guava cache 机制
Cache数据结构
类似 1.7 ConcurrentHashMap，结构是 Segement 数组 + HashEntry数组 + 链表。

关键参数
- expireAfterWrite 当缓存项在指定的时间内没有更新就会被回收
- expireAfterAccess 当缓存项在指定的时间内没有被读或写就会被回收
- refreshAfterWrite 当缓存项上一次更新操作之后的多久会被刷新
- concurrencyLevel 并发级别，使得缓存支持并发的写入和读取

refreshAfterWrite
特点是，在refresh的过程中，严格限制只有1个重新加载操作，而其他查询先返回旧值，这样有效地可以减少等待和锁争用。但不能严格保证所有的查询都获取到新值。

回收机制
- 基于容量回收：在缓存项的数目达到限定值之前，采用LRU的回收方式
- 定时回收：expireAfterAccess，缓存项在给定时间内没有被读/写访问，则回收，回收顺序和基于大小回收一样（LRU）；expireAfterWrite，缓存项在给定时间内没有被写访问（创建或覆盖），则回收
- 基于引用回收：通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache可以垃圾回收