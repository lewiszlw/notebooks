# BigInt(20) 和 Int(20) 辨别

括号里的数字只用于填充0（ZEROFILL），而跟能存储数字的大小没有区别，所以基本没用，因为一般不会打开ZEROFILL选项。

BigInt存储8字节有符号整数，Int存储4字节有符号整数。

https://stackoverflow.com/questions/3135804/types-in-mysql-bigint20-vs-int20

# SQL优化
1.limit当offset很大时性能低下，改用子查询的分页方式或者JOIN分页方式（使用字段带有索引）。原理：子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。
```sql
-- 传统limit，文件扫描
[SQL]SELECT * FROM tableName ORDER BY id LIMIT 500000,2;
受影响的行: 0
时间: 5.371s

-- 子查询方式，索引扫描
[SQL]
SELECT * FROM tableName
WHERE id >= (SELECT id FROM tableName ORDER BY id LIMIT 500000 , 1)
LIMIT 2;
受影响的行: 0
时间: 0.274s

-- JOIN分页方式
[SQL]
SELECT *
FROM tableName AS t1
JOIN (SELECT id FROM tableName ORDER BY id desc LIMIT 500000, 1) AS t2
WHERE t1.id <= t2.id ORDER BY t1.id desc LIMIT 2;
受影响的行: 0
时间: 0.278s
```

# SQL优化原则
1.避免join、子查询

2.update尽量少量更新，避免造成主从延迟

3.避免NULL，难以优化

4.使用索引

# MYSQL引擎类型
1.ISAM：ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。不支持事务处理，也不能够容错。

2.MYISAM：提供ISAM里所没有的索引和字段管理的大量功能。优化多个并发的读写操作。

3.HEAP：允许只驻留在内存里的临时表格

4.INNODB

5.BERKLEY（BDB）

INNODB和BDB包括了对事务处理和外来键的支持

# 数据库并发控制
**1.悲观锁**

如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
- 排它锁（写锁）：若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁
```sql
set autocommit=0; (不自动提交事务)
begin;/begin work;/start transaction; (三者选一就可以)
select status from TABLE where id=1 for update;
insert into TABLE (id,value) values (2,2);
update TABLE set value=2 where id=1;
commit;/commit work;
```
排它锁会阻塞所有的排它锁和共享锁
- 共享锁（读锁）：其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁
```sql
begin;/begin work;/start transaction;  (三者选一就可以)
SELECT * from TABLE where id = 1  lock in share mode;
```
加上共享锁后，对于update,insert,delete语句会自动加排它锁

优点与不足：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

**2.乐观锁**

它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。乐观锁相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

优点与不足：乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

# 数据库锁
**行级锁**

行锁分为：`共享锁`和`排他锁`。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。

**表级锁**

表锁：innodb 的行锁是在有索引的情况下，没有索引的表是锁定全表的。

**页级锁**
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。


# 数据库隔离级别
**1.Read uncommitted 读未提交**

**2.Read committed 读提交**

解决：脏读

**3.Repeatable read 重复读**

解决：脏读、不可重复读

**4.Serializable 序列化**

解决：脏读、不可重复读、幻读

# 脏读、不可重复读、幻读
**1.读“脏”数据（Dirty Read）**

读“脏”数据是指：事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，T2读到的数据就为“脏”数据，即不正确的数据。

**2.不可重复读（Non-repeatable Read）**

不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。

不可重复读包括三种情况：
  - 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值 
  - 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了 
  - 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录

**3.幻读**

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

# 数据库三范式
**第一范式(1st NF －列都是不可再分)**

第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%E7%A4%BA%E4%BE%8B.png)

**第二范式(2nd NF－每个表只描述一件事情)**

首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一件事情。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E7%A4%BA%E4%BE%8B.png)

**第三范式(3rd NF－ 不存在对非主键列的传递依赖)**

第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E7%A4%BA%E4%BE%8B.png)

# 数据库事务特性
**原子性（Atomicity）**

事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。

**一致性（Consistency）**

当事务完成时，数据必须处于一致状态。

**隔离性（Isolation）**

对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。

**永久性（Durability）**

事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。

# 聚簇索引和非聚簇索引
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

聚簇索引的顺序就是数据的物理存储顺序，非聚簇索引的索引顺序与数据物理排列顺序无关。

# B 树 (B-tree) 和 B+ 树
**B树（B-tree）**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/storage/B%E6%A0%91.png)

1. 定义任意非叶子结点最多只有M个儿子，且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]；
4. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8. 所有叶子结点位于同一层；

**B+树**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/storage/B%2B%E6%A0%91.png)

1. 非叶子节点的子树指针与关键字个数相同；
2. 非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；
3. 为所有叶子节点增加一个链指针；
4. 所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)；
5. 非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层；

**B+树相对于B树优点**：
1. B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。
2. B+树更适合外部存储，由于内节点无 data 域，一个结点可以存储更多的内结点，每个节点能索引的范围更大更精确，也意味着 B+树单次磁盘IO的信息量大于B树，I/O效率更高。

