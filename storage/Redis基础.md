# Redis过期策略
**1.定期删除**

redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

**2.惰性删除**

在获取某个 key 的时候，redis 会检查一下 ，如果这个 key 设置了过期时间，并且已经过期了，那么就直接删除，返回空。

ps.如果大量的key没有被扫描到，且已过期，也没有被再次访问，即没有走惰性删除，这些大量过期 key 堆积在内存里，导致 redis 内存块耗尽了：redis提供内存淘汰机制（如LRU）。

# Redis优缺点
优点：
1. 数据存放在内存中，读写速度很快，采用单线程结构，防止了因多线程竞争可能出现的问题和消耗。
2. 数据类型丰富，五种基础数据类型，并且有很多很有用的扩展数据类型，如位图，HyperLogLog，发布订阅，GEO 等。
3. 功能丰富，提供键过期，简单事务，Lua 脚本管理，Pipeline 等功能。
4. 数据可持久化，可通过 RDB 和 AOF 两种方式进行数据持久化。
5. 提供主从复制，可利用集群，哨兵构建高可用的分布式架构。

缺点：
1. 不具备自动容错和恢复功能。
2. 主机宕机，宕机未同步到从机的数据无法恢复。
3. 主从复制采用全量复制，若快照文件过大，对集群的服务能力会产生较大影响。
4. 难以支持在线扩容。

# Redis高性能原因
1. 完全基于内存
2. 采用单线程，避免了不必要的上下文切换和竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 使用多路I/O复用模型，非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架
4. 数据结构简单

# Redis单线程原因
官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。