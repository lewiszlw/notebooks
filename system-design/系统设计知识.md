# 文章海量评论分页设计
**场景**：

文章的评论量非常大, 比如说一篇热门文章就有几百万的评论, 设计一个后端服务, 实现评论的时序展示与分页。

**设计**：

1.不支持页码跳转：传评论id 用 offset 实现翻页，(文章id, 评论id) 建联合索引，评论 id 需递增。

如果表中存在`连续`的数字列并为索引，那么通过页码即可计算出此字段的范围，直接作范围查询即可：
```
start = (page-1) * pagesize
end = page * pagesize
select * from table where id > start and id <= end
```

2.支持页码跳转：不能做精准深分页，否则压力太大，在50或100页后数据分页是否可以不完全精确，假如可以，那么缓存深页码的起始评论 id。

# 分库分表下的分页查询
每张表查 N 条数据，数据在服务层进行内存排序，得到数据全局视野，再取目标页数据，便能够得到想要的全局分页数据。

# 缓存重建
1. 互斥锁：只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可
2. 永不过期：从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。

# 六边形架构
![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/system-design/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.jpg)

在六边形架构风格中，应用程序的内部（中间的橙色六边形）包含业务规则，基于业务规则的计算，领域对象，领域事件等。而外部的，也是我们平时最熟悉的诸如REST，SOAP，NoSQL，SQL，Message Queue等，都通过一个端口接入，然后在内外之间有一个适配器组成的层，它负责将不同端口来的数据进行转换，翻译成领域内部可以识别的概念（领域对象，领域事件等）。

内部不关心数据从何而来，不关心数据如何存储，不关心输出时JSON还是XML，事实上它对调用者一无所知，它可以处理的数据已经是经过适配器转换过的领域对象了。

# SOLID原则
**单一责任原则（The Single Responsibility Principle）**

一个类只应承担一种责任。

**开放封闭原则（The Open Closed Principle）**

实体应该对扩展是开放的，对修改是封闭的。

举例：比如系统支付方式有多种，每新增一种需要修改原有代码，可以抽离出来一个PayHandler接口，这样新增支付方式只需要新增一个PayHandler实现类即可，不用改动原有代码。

**里氏替换原则（Liskov Substitution Principle）**

一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。

**接口分离原则（The Interface Segregation Principle）**

客户(client)不应被强迫依赖它不使用的方法。即，一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构、更改。

**依赖倒置原则（The Dependency Inversion Principle）**
高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象；抽象不应依赖于具体实现，具体实现应依赖抽象。

举例：数据库连接Driver、六边形架构、MVC模式中面向接口编程