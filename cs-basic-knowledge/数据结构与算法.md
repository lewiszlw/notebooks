# 限流算法
**令牌桶**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E5%9B%BE.png)

令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。

**漏桶**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E5%9B%BE.png)

把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。

**令牌桶和漏桶区别**：

漏桶算法能够强行限制数据的传输速率，而令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。

# 最短路径算法
// TODO 后续补充

**Dijkstra算法**
白话：从起源点开始找路径最短的下一个点，不构成环形。

https://www.jianshu.com/p/a8f9c6b69915

https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html

**Floyd算法**

# 红黑树
红黑树是一种 自平衡 的二叉树，所谓的自平衡是指在插入和删除的过程中，红黑树会采取一定的策略对树的组织形式进行调整，以尽可能的减少树的高度，从而节省查找的时间。

**特点**
1. 时间复杂度低，O(lgN)
2. 自平衡

# 判断链表是否有环、两个链表是否相交 
第一部分——判断单个链表是否有环

使用两个指针，一个快指针，一个慢指针，快指针一次走两步，慢指针一次走一步；
若快指针最后变为空，则单链表为无环单链表，返回空指针；
若快慢指针在某一时刻指向同一节点，即二者完全一样，则为有环单链表，
此时让快指针重新指向链表头结点，然后快慢指针均一次走一步，
当快慢指针再次相同时，则此节点即为链表入环节点，将其返回。

第二部分——判断链表是否相交

情况一：两链表中一个为有环链表，一个为无环链表，则此时两链表一定不相交，返回空即可；

情况二：两个链表都是无环链表，此时有两种情况，1）两个无环链表相交；2）两个无环链表不相交；
首先遍历两链表，分别得到两个链表的长度，
取两个长度的差值，然后让长链表先遍历差值长度，此时长链表剩余部分与短链表长度相同，
然后两条链表同时遍历，直到遇到相同节点为止，若相同节点为空，则两链表不相交，返回空，
否则两链表相交，返回相交节点即可；

情况三：两个链表都是有环链表，此时有三种情况，1）两个有环链表不相交；2）两个有环链表相交，且交点在环外；3）两个有环链表相交，且交点在环内。
首先获得两个链表的入环节点，若入环节点相同，则可转变为情况二，此时将入环节点作为链表的终止节点即可；若两个入环节点不同，以一个入环节点开始遍历，若遍历一遍过程中都没有遇见另一个入环节点，则两链表不相交，返回空，若遇到另一入环节点，则说明两链表相交，此时返回任意一个入环节点即可。