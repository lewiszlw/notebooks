# 限流算法
**令牌桶**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E5%9B%BE.png)

令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。

**漏桶**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E5%9B%BE.png)

把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。

**令牌桶和漏桶区别**：

漏桶算法能够强行限制数据的传输速率，而令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。

# 最短路径算法
// TODO 后续补充

**Dijkstra算法**
白话：从起源点开始找路径最短的下一个点，不构成环形。

https://www.jianshu.com/p/a8f9c6b69915

https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html

**Floyd算法**

# 红黑树
红黑树是一种 自平衡 的二叉树，所谓的自平衡是指在插入和删除的过程中，红黑树会采取一定的策略对树的组织形式进行调整，以尽可能的减少树的高度，从而节省查找的时间。

**特点**
1. 时间复杂度低，O(lgN)
2. 自平衡

# 判断链表是否有环、两个链表是否相交 
第一部分——判断单个链表是否有环

使用两个指针，一个快指针，一个慢指针，快指针一次走两步，慢指针一次走一步；
若快指针最后变为空，则单链表为无环单链表，返回空指针；
若快慢指针在某一时刻指向同一节点，即二者完全一样，则为有环单链表，
此时让快指针重新指向链表头结点，然后快慢指针均一次走一步，
当快慢指针再次相同时，则此节点即为链表入环节点，将其返回。

第二部分——判断链表是否相交

情况一：两链表中一个为有环链表，一个为无环链表，则此时两链表一定不相交，返回空即可；

情况二：两个链表都是无环链表，此时有两种情况，1）两个无环链表相交；2）两个无环链表不相交；
首先遍历两链表，分别得到两个链表的长度，
取两个长度的差值，然后让长链表先遍历差值长度，此时长链表剩余部分与短链表长度相同，
然后两条链表同时遍历，直到遇到相同节点为止，若相同节点为空，则两链表不相交，返回空，
否则两链表相交，返回相交节点即可；

情况三：两个链表都是有环链表，此时有三种情况，1）两个有环链表不相交；2）两个有环链表相交，且交点在环外；3）两个有环链表相交，且交点在环内。
首先获得两个链表的入环节点，若入环节点相同，则可转变为情况二，此时将入环节点作为链表的终止节点即可；若两个入环节点不同，以一个入环节点开始遍历，若遍历一遍过程中都没有遇见另一个入环节点，则两链表不相交，返回空，若遇到另一入环节点，则说明两链表相交，此时返回任意一个入环节点即可。

# 一致性Hash算法

**解决的问题**

避免在节点扩容的情况下，使用hash函数计算桶位置会有变化。如redis集群有 4 台服务器，使用key % 4 = 2 定位 key 读写在 2 号服务器，当redis集群扩容到 5 台，这时候 key % 5 不等于 2。

**一致性Hash算法原理**

一致性Hash算法是对2^32取模，将整个哈希值空间组织成一个虚拟的圆环：

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E5%93%88%E5%B8%8C%E7%8E%AF.jpg)

然后将服务器通过ip或主机名进行hash，如下图的Node A、Node B、Node C、Node D，接下来使用如下算法定位数据访问到相应服务器：`将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器`。数据对象进行hash，如下图的Object A、Object B、Object C、Object D，根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg)

**一致性Hash算法的容错性和可扩展性**

假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%AE%B9%E9%94%99%E6%80%A7%E5%9B%BE%E7%A4%BA.jpg)

如果在系统中增加一台服务器Node X，此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E5%9B%BE%E7%A4%BA.jpg)

**哈希环数据倾斜问题**

致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E5%93%88%E5%B8%8C%E7%8E%AF%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98%E5%9B%BE%E7%A4%BA.jpg)

为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即`对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点`。具体做法可以在服务器IP或主机名的后面增加编号来实现。如可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E5%9B%BE%E7%A4%BA.jpg)