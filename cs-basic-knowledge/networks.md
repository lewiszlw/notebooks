# 单工、半双工、全双工通信
单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。

半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。

全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。

# 局域网广播
广播是主机之间`一对所有`的通讯模式，在IP网络中，广播地址用IP地址“255.255.255.255”来表示，这个IP地址代表同一子网内所有的IP地址。

# 网络七层模型
**1.物理层**

主要定义物理设备标准。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。

这一层的数据叫做比特。 

**2.数据链路层**

主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。在这一层工作的设备是交换机，数据通过交换机来传输。

常把这一层的数据叫做帧。

**3.网络层**

主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器。

常把这一层的数据叫做数据包。

**4.传输层**

定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议），UDP（用户数据报协议）。主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。

常常把这一层数据叫做段。

**5.会话层**

通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）。

**6.表示层**

主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西，如图片、声音等）。

**7.应用层**

主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（理解成我们在电脑屏幕上可以看到的东西，就是终端用）。

# TCP/IP协议族
**1.网络访问层(Network Access Layer)**

指出主机必须使用某种协议与网络相连。

**2.网络层(Internet Layer)**

使用因特网协议(IP，Internet Protocol)。

**3.传输层(Tramsport Layer-TCP/UDP)**

在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。

TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。

**4.应用层(Application Layer)**

应用层(Application Layer)包含所有的高层协议，包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。

# TCP/IP 五元组
源IP地址、目的IP地址、源端口、目的端口、传输层协议

# TCP协议端口号
**TCP端口号范围**

0 ~ 65535，因为tcp（udp）首部用原端口和目的端口都只有16位（1111111 11111111 = 65535）。

**TCP端口号分类**
1. 公认端口（Well-known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。
2. 注册端口（Registered Ports）：端口1024到49151，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。
3. 动态端口（Dynamic Ports）：从49152到65535，一般不固定分配某种服务，而是动态分配。

# TCP三次握手/四次挥手

**三次握手**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；

第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的 seq+1),syn=1,ack=1,随机产生 seq=7654321 的包

第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1，以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。

**四次挥手**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。

1. 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u。服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。
2. 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给 B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到 close 状态。

**顺序号 seq（ 32 位）**：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1。

**确认号 ack（ 32 位）**：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。

**ACK**：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。

**SYN** ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。

**FIN** ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。

**FAQ：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

**FAQ：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

1. 保证TCP协议的全双工连接能够可靠关闭
如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。
2. 保证这次连接的重复数据段从网络中消失
如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

**FAQ：TIME_WAIT过多有什么影响？**

在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。因为Linux分配给一个用户的文件句柄是有上限的。

**FAQ：CLOSE_WAIT过多有什么影响？**

当有大量CLOSE_WAIT的时候会占用服务器的fd，而一个机器能打开的fd数量是有限制的，超过了则无法分配fd，就无法建立新连接。

**FAQ：TIME_WAIT只存在Client端吗？**

不是，TIME_WAIT存在于TCP四次挥手发起方，如果是server端发起断开连接，则TIME_WAIT存在于server端。

# TCP如何保证可靠传输
**1、确认和重传**：

接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。

**2、数据校验**

**3、数据合理分片和排序**：

UDP IP数据报大于1500字节，大于MTU。这个时候发送方IP层就需要分片(fragmentation)。把数据报分成若干片，使每一片都小于MTU。而接收方IP层则需要进行数据报的重组。这样就会多做许多事情，而更严重的是，由于UDP的特性，当某一片数据传送中丢失时，接收方便无法重组数据报，将导致丢弃整个UDP数据报。

TCP 会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。

**4、流量控制**：

当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。

**5、拥塞控制**：

当网络拥塞时，减少数据的发送。

拥塞控制算法
1. 慢开始
2. 拥塞控制
3. 快重传
4. 快恢复

![TCP拥塞控制](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/cs-basic-knowledge/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png)

# Socket建立过程
1. 服务器监听 (bind、connect、listen、accept)
2. 客户端请求 (connect)
3. 连接确认

# TCP 与 UDP 对比和应用场景
对比
1. TCP 面向流，UDP 面向报文
2. TCP 需要建立连接，UDP 无连接
3. TCP 具有可靠性，UDP 不可靠
4. TCP 保证数据顺序，UDP 不保证顺序
5. TCP 有流量控制，UDP 没有

应用
- TCP：web服务
- UPD：直播，在线视频，网络语音电话