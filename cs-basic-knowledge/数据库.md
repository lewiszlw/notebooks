# SQL优化
## SQL优化原则
1.避免join、子查询

2.update尽量少量更新，避免造成主从延迟

3.避免NULL，难以优化

4.使用索引

# 数据库引擎
## MYSQL引擎
1.ISAM：ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。不支持事务处理，也不能够容错。

2.MYISAM：提供ISAM里所没有的索引和字段管理的大量功能。优化多个并发的读写操作。

3.HEAP：允许只驻留在内存里的临时表格

4.INNODB

5.BERKLEY（BDB）

INNODB和BDB包括了对事务处理和外来键的支持

# 数据库锁

## 乐观锁和悲观锁
悲观锁和乐观锁是一种并发控制方法。

1.悲观锁：如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
- 排它锁（写锁）：若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁
```sql
set autocommit=0; (不自动提交事务)
begin;/begin work;/start transaction; (三者选一就可以)
select status from TABLE where id=1 for update;
insert into TABLE (id,value) values (2,2);
update TABLE set value=2 where id=1;
commit;/commit work;
```
排它锁会阻塞所有的排它锁和共享锁
- 共享锁（读锁）：其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁
```sql
begin;/begin work;/start transaction;  (三者选一就可以)
SELECT * from TABLE where id = 1  lock in share mode;
```
加上共享锁后，对于update,insert,delete语句会自动加排它锁

优点与不足：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

2.乐观锁
它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。乐观锁相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

优点与不足：乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

## 行锁和表锁
- 行锁分为：`共享锁`和`排他锁`。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。
- 表锁：innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的。

# 数据库隔离级别
1.Read uncommitted 读未提交

2.Read committed 读提交

解决：脏读

3.Repeatable read 重复读

解决：脏读、不可重复读

4.Serializable 序列化

解决：脏读、不可重复读、幻读

# 脏读、不可重复读、幻读
1.读“脏”数据（Dirty Read）

读“脏”数据是指：事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，T2读到的数据就为“脏”数据，即不正确的数据。

2.不可重复读（Non-repeatable Read）

不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。

不可重复读包括三种情况：
  - 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值 
  - 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了 
  - 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录

3.幻读

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。