# BIO、NIO和AIO区别
1.BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

2.NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

3.AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

# 自旋锁
自旋锁（spin lock）是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。（[自旋锁Java实现]()）

自旋锁问题
1. 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。
2. 上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。
3. 死锁问题：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。

自旋锁优点
1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
2. 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）

# 公平锁和非公平锁
- 公平锁：指线程在等待获取同一个锁的时候，是严格按照申请锁的时间顺序来进行的
- 非公平锁：随机线程获取锁，效率相对高

# 可重入锁和不可重入锁
- 可重入锁：当一个线程获取了A锁以后，若后续方法运行被A锁锁住的话，当前线程也是可以直接进入的
- 不可重入锁：当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

# 死锁产生条件
1. 互斥条件：一个资源每次只能被一个进程使用。 
2. 请求与保持条件（部分分配）：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
3. 不可剥夺条件：进程已获得的资源，在使用完之前，不能强行剥夺。
4. 循环等待条件（环路）：若干进程之间形成一种头尾相接的循环等待资源关系。

# 进程调度算法
// TODO

# 进程间通信方式
// TODO

# UNIX 五种IO模型
**1.阻塞 IO 模型**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/linux/Unix%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E6%A8%A1%E5%9E%8B.jpeg)

典型的阻塞 IO 模型的例子为:data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。

**2.非阻塞 IO 模型**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/linux/Unix%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E6%A8%A1%E5%9E%8B.jpeg)

当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。

用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。

**3.多路复用 IO 模型**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/linux/Unix%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%A8%A1%E5%9E%8B.jpeg)

有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。

另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态
时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。

**4.信号驱动 IO 模型**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/linux/Unix%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.jpeg)

在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。

**5.异步 IO 模型**

![image](https://raw.githubusercontent.com/lewiszlw/notebooks/master/assets/linux/Unix%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.jpeg)

异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接 去使用数据了。