# 内存溢出原因
1.不断的new对象

2.对象过大，超过堆大小

3.内存泄漏，导致内存无法回收

4.永久代内存溢出：Class过多

# 元数据区
在 Java8 中，**永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代**。`元空间` 的本质和永久代类似，元空间与永久代之间最大的区别在于: **元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。

# GC垃圾收集器
**新生代**
1. Serial 垃圾收集器(单线程、复制算法)：是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。
2. ParNew垃圾收集器(Serial+多线程)：是很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器。
3. Parallel Scavenge 收集器(多线程复制算法、高效)：吞吐量。

**老年代**
1. SerialOld收集器(单线程标记整理算法)：运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。
2. ParallelOld收集器(多线程标记整理算法)
3. CMS收集器(多线程标记清除算法)：主要目标是获取最短垃圾 回收停顿时间。
4. G1收集器
