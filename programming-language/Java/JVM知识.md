# 内存溢出原因
1.不断的new对象

2.对象过大，超过堆大小

3.内存泄漏，导致内存无法回收

4.永久代内存溢出：Class过多

# 元数据区
在 Java8 中，**永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代**。`元空间` 的本质和永久代类似，元空间与永久代之间最大的区别在于: **元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。

# GC垃圾收集器
**新生代**
1. Serial 垃圾收集器(单线程、复制算法)：是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。
2. ParNew垃圾收集器(Serial+多线程)：是很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器。
3. Parallel Scavenge 收集器(多线程复制算法、高效)：吞吐量。

**老年代**
1. SerialOld收集器(单线程标记整理算法)：运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。
2. ParallelOld收集器(多线程标记整理算法)
3. CMS收集器(多线程标记清除算法)：主要目标是获取最短垃圾 回收停顿时间。
4. G1收集器

# JVM类加载机制
JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。

**1.加载**

加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

**2.验证**

确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**3.准备**

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

**4.解析**

虚拟机将常量池中的符号引用替换为直接引用的过程。

**5.初始化**

初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。

# JVM类加载器
**1.启动类加载器(Bootstrap ClassLoader)**

负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。

**2.扩展类加载器(Extension ClassLoader)**

负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs 系统变量指定路径中的类库。

**3.应用程序类加载器(Application ClassLoader)**

负责加载用户路径（classpath）上的类库。